---
phase: 01-room-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/build.gradle.kts
  - data/src/main/java/com/wenubey/data/local/WenuCommerceDatabase.kt
  - data/src/main/java/com/wenubey/data/local/entity/ProductEntity.kt
  - data/src/main/java/com/wenubey/data/local/entity/CategoryEntity.kt
  - data/src/main/java/com/wenubey/data/local/entity/UserEntity.kt
  - data/src/main/java/com/wenubey/data/local/dao/ProductDao.kt
  - data/src/main/java/com/wenubey/data/local/dao/CategoryDao.kt
  - data/src/main/java/com/wenubey/data/local/dao/UserDao.kt
  - data/src/main/java/com/wenubey/data/local/converter/RoomTypeConverters.kt
  - data/src/main/java/com/wenubey/data/local/mapper/ProductMapper.kt
  - data/src/main/java/com/wenubey/data/local/mapper/CategoryMapper.kt
  - data/src/main/java/com/wenubey/data/local/mapper/UserMapper.kt
  - app/src/main/java/com/wenubey/wenucommerce/di/DataModule.kt
  - app/src/main/java/com/wenubey/wenucommerce/di/AppModules.kt
autonomous: true
requirements:
  - SYNC-01

must_haves:
  truths:
    - "Room database singleton is created by Koin and accessible throughout the app"
    - "ProductEntity, CategoryEntity, and UserEntity map bidirectionally to their domain models without data loss"
    - "Room schema version 1 JSON is exported to data/schemas/ and tracked in git"
    - "Duplicate Room declarations in app/build.gradle.kts are removed; Room KSP runs only in data module"
    - "fallbackToDestructiveMigration is NOT present in release build config"
  artifacts:
    - path: "data/src/main/java/com/wenubey/data/local/WenuCommerceDatabase.kt"
      provides: "Room database class with version 1"
      contains: "@Database"
    - path: "data/src/main/java/com/wenubey/data/local/entity/ProductEntity.kt"
      provides: "Product Room entity"
      contains: "@Entity"
    - path: "data/src/main/java/com/wenubey/data/local/entity/CategoryEntity.kt"
      provides: "Category Room entity"
      contains: "@Entity"
    - path: "data/src/main/java/com/wenubey/data/local/entity/UserEntity.kt"
      provides: "User Room entity"
      contains: "@Entity"
    - path: "data/src/main/java/com/wenubey/data/local/dao/ProductDao.kt"
      provides: "Product DAO with Flow queries and upsert"
      contains: "@Dao"
    - path: "data/src/main/java/com/wenubey/data/local/dao/CategoryDao.kt"
      provides: "Category DAO with Flow queries and upsert"
      contains: "@Dao"
    - path: "data/src/main/java/com/wenubey/data/local/dao/UserDao.kt"
      provides: "User DAO with Flow query and upsert"
      contains: "@Dao"
    - path: "data/src/main/java/com/wenubey/data/local/converter/RoomTypeConverters.kt"
      provides: "JSON TypeConverters for nested types"
      contains: "@TypeConverter"
    - path: "data/src/main/java/com/wenubey/data/local/mapper/ProductMapper.kt"
      provides: "Product <-> ProductEntity bidirectional mapping"
      contains: "fun ProductEntity.toDomain"
    - path: "data/src/main/java/com/wenubey/data/local/mapper/CategoryMapper.kt"
      provides: "Category <-> CategoryEntity bidirectional mapping"
      contains: "fun CategoryEntity.toDomain"
    - path: "data/src/main/java/com/wenubey/data/local/mapper/UserMapper.kt"
      provides: "User <-> UserEntity bidirectional mapping"
      contains: "fun UserEntity.toDomain"
  key_links:
    - from: "data/src/main/java/com/wenubey/data/local/WenuCommerceDatabase.kt"
      to: "ProductDao, CategoryDao, UserDao"
      via: "abstract fun declarations"
      pattern: "abstract fun productDao\\(\\)"
    - from: "app/src/main/java/com/wenubey/wenucommerce/di/DataModule.kt"
      to: "data/src/main/java/com/wenubey/data/local/WenuCommerceDatabase.kt"
      via: "Koin databaseModule single{} providing Room.databaseBuilder"
      pattern: "Room\\.databaseBuilder"
    - from: "app/src/main/java/com/wenubey/wenucommerce/di/AppModules.kt"
      to: "databaseModule"
      via: "appModules list includes databaseModule"
      pattern: "databaseModule"
---

<objective>
Set up the Room database infrastructure: entities, DAOs, TypeConverters, domain mappers, and Koin DI wiring.

Purpose: Establish the Room persistence layer that all subsequent repository migrations depend on. This is the foundation — no repository can read from Room until these artifacts exist and the database compiles.

Output: WenuCommerceDatabase (schema v1) with ProductEntity, CategoryEntity, UserEntity, their DAOs and mappers, TypeConverters for nested JSON types, databaseModule registered in Koin, and duplicate Room deps removed from app module.
</objective>

<execution_context>
@/Users/wenubey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wenubey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-room-foundation/01-RESEARCH.md

@app/build.gradle.kts
@data/build.gradle.kts
@domain/src/main/java/com/wenubey/domain/model/product/Product.kt
@domain/src/main/java/com/wenubey/domain/model/product/Category.kt
@domain/src/main/java/com/wenubey/domain/model/product/Subcategory.kt
@domain/src/main/java/com/wenubey/domain/model/product/ProductImage.kt
@domain/src/main/java/com/wenubey/domain/model/product/ProductVariant.kt
@domain/src/main/java/com/wenubey/domain/model/product/ProductShipping.kt
@domain/src/main/java/com/wenubey/domain/model/product/ProductStatus.kt
@domain/src/main/java/com/wenubey/domain/model/product/ProductCondition.kt
@domain/src/main/java/com/wenubey/domain/model/product/ShippingType.kt
@domain/src/main/java/com/wenubey/domain/model/user/User.kt
@domain/src/main/java/com/wenubey/domain/model/user/UserRole.kt
@domain/src/main/java/com/wenubey/domain/model/Device.kt
@domain/src/main/java/com/wenubey/domain/model/Purchase.kt
@domain/src/main/java/com/wenubey/domain/model/onboard/BusinessInfo.kt
@domain/src/main/java/com/wenubey/domain/model/Gender.kt
@app/src/main/java/com/wenubey/wenucommerce/di/DataModule.kt
@app/src/main/java/com/wenubey/wenucommerce/di/AppModules.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove duplicate Room dependencies from app module and create Room entities, DAOs, TypeConverters, and Database</name>
  <files>
    app/build.gradle.kts
    data/src/main/java/com/wenubey/data/local/entity/ProductEntity.kt
    data/src/main/java/com/wenubey/data/local/entity/CategoryEntity.kt
    data/src/main/java/com/wenubey/data/local/entity/UserEntity.kt
    data/src/main/java/com/wenubey/data/local/converter/RoomTypeConverters.kt
    data/src/main/java/com/wenubey/data/local/dao/ProductDao.kt
    data/src/main/java/com/wenubey/data/local/dao/CategoryDao.kt
    data/src/main/java/com/wenubey/data/local/dao/UserDao.kt
    data/src/main/java/com/wenubey/data/local/WenuCommerceDatabase.kt
  </files>
  <action>
    **Step 1: Remove Room from app/build.gradle.kts.**
    Delete these four lines from the `dependencies` block:
    ```
    ksp(libs.room.compiler)
    implementation(libs.room.runtime)
    implementation(libs.room.paging)
    implementation(libs.room.ktx)
    ```
    Also remove the `// Room` comment above them. Leave the `// KSP` section (`implementation(libs.ksp)`) untouched — it is the KSP symbol processing API, not Room.

    **Step 2: Create the directory structure.**
    Create directories: `data/src/main/java/com/wenubey/data/local/entity/`, `data/src/main/java/com/wenubey/data/local/dao/`, `data/src/main/java/com/wenubey/data/local/converter/`.

    **Step 3: Create RoomTypeConverters.kt** in `data/src/main/java/com/wenubey/data/local/converter/`.
    - Package: `com.wenubey.data.local.converter`
    - Class with `@TypeConverter` methods for:
      - `List<String>` <-> JSON String (using `kotlinx.serialization.json.Json`)
      - `List<ProductImage>` <-> JSON String
      - `List<ProductVariant>` <-> JSON String
      - `ProductShipping` <-> JSON String
      - `List<Subcategory>` <-> JSON String
      - `List<Purchase>` <-> JSON String
      - `List<Device>` <-> JSON String
      - `BusinessInfo?` <-> JSON String (nullable)
      - `Map<String, String>` <-> JSON String (for ProductVariant.attributes)
    - Use a private `val json = Json { ignoreUnknownKeys = true; coerceInputValues = true }` instance.
    - Every deserialization method MUST use `runCatching { }.getOrElse { defaultValue }` for crash protection.
    - Import domain model types from `com.wenubey.domain.model.product.*` and `com.wenubey.domain.model.*`.

    **Step 4: Create ProductEntity.kt** in `data/src/main/java/com/wenubey/data/local/entity/`.
    - Package: `com.wenubey.data.local.entity`
    - `@Entity(tableName = "products")` data class with `@PrimaryKey val id: String`
    - All simple fields from Product domain model as direct columns: `title`, `description`, `slug`, `sellerId`, `sellerName`, `sellerLogoUrl`, `categoryId`, `categoryName`, `subcategoryId`, `subcategoryName`, `basePrice`, `compareAtPrice` (nullable Double), `currency`, `status` (String — store `ProductStatus.name`), `condition` (String — store `ProductCondition.name`), `averageRating`, `reviewCount`, `totalStockQuantity`, `hasVariants`, `viewCount`, `purchaseCount`, `moderationNotes`, `suspendedBy`, `suspendedAt`, `stripeProductId`, `createdAt`, `updatedAt`, `publishedAt`, `archivedAt`.
    - Nested/list fields stored as JSON strings with TypeConverter: `imagesJson: String = "[]"` (List<ProductImage>), `variantsJson: String = "[]"` (List<ProductVariant>), `shippingJson: String = "{}"` (ProductShipping), `tagsJson: String = "[]"` (List<String>), `tagNamesJson: String = "[]"` (List<String>), `searchKeywordsJson: String = "[]"` (List<String>).
    - Every JSON column MUST have a default value (empty JSON array `"[]"` or empty object `"{}"`).

    **Step 5: Create CategoryEntity.kt** in `data/src/main/java/com/wenubey/data/local/entity/`.
    - Package: `com.wenubey.data.local.entity`
    - `@Entity(tableName = "categories")` with `@PrimaryKey val id: String`
    - Columns: `name`, `description`, `imageUrl`, `isActive` (Boolean), `createdBy`, `createdAt`, `updatedAt`.
    - `subcategoriesJson: String = "[]"` for `List<Subcategory>` via TypeConverter.

    **Step 6: Create UserEntity.kt** in `data/src/main/java/com/wenubey/data/local/entity/`.
    - Package: `com.wenubey.data.local.entity`
    - `@Entity(tableName = "users")` with `@PrimaryKey val id: String` (maps to User.uuid).
    - Simple columns: `role` (String — UserRole.name), `name`, `surname`, `phoneNumber`, `dateOfBirth`, `gender` (String — Gender.name), `email`, `address`, `isEmailVerified` (Boolean), `isPhoneNumberVerified` (Boolean), `profilePhotoUri`, `createdAt`, `updatedAt`, `signedAt`.
    - JSON columns: `purchaseHistoryJson: String = "[]"` (List<Purchase>), `signedDevicesJson: String = "[]"` (List<Device>), `businessInfoJson: String? = null` (BusinessInfo?), `productsJson: String = "[]"` (List<String> — product IDs).

    **Step 7: Create ProductDao.kt** in `data/src/main/java/com/wenubey/data/local/dao/`.
    - Package: `com.wenubey.data.local.dao`
    - `@Dao` interface with methods:
      - `@Query("SELECT * FROM products WHERE status = 'ACTIVE' AND categoryId = :categoryId") fun observeActiveProductsByCategory(categoryId: String): Flow<List<ProductEntity>>`
      - `@Query("SELECT * FROM products WHERE status = 'ACTIVE' AND categoryId = :categoryId AND subcategoryId = :subcategoryId") fun observeActiveProductsByCategoryAndSubcategory(categoryId: String, subcategoryId: String): Flow<List<ProductEntity>>`
      - `@Query("SELECT * FROM products WHERE status = 'ACTIVE'") fun observeAllActiveProducts(): Flow<List<ProductEntity>>`
      - `@Query("SELECT * FROM products WHERE id = :id LIMIT 1") suspend fun getProductById(id: String): ProductEntity?`
      - `@Query("SELECT * FROM products WHERE sellerId = :sellerId") fun observeSellerProducts(sellerId: String): Flow<List<ProductEntity>>`
      - `@Query("SELECT * FROM products WHERE status = :status") fun observeProductsByStatus(status: String): Flow<List<ProductEntity>>`
      - `@Query("SELECT * FROM products WHERE status = 'ACTIVE' AND (title LIKE '%' || :query || '%' OR categoryName LIKE '%' || :query || '%' OR searchKeywordsJson LIKE '%' || :query || '%')") suspend fun searchActiveProducts(query: String): List<ProductEntity>`
      - `@Query("SELECT * FROM products WHERE title LIKE '%' || :query || '%' OR categoryName LIKE '%' || :query || '%' OR searchKeywordsJson LIKE '%' || :query || '%'") suspend fun searchAllProducts(query: String): List<ProductEntity>`
      - `@Upsert suspend fun upsertAll(products: List<ProductEntity>)`
      - `@Upsert suspend fun upsert(product: ProductEntity)`
      - `@Query("DELETE FROM products WHERE id = :id") suspend fun deleteById(id: String)`
      - `@Query("DELETE FROM products") suspend fun clearAll()`

    **Step 8: Create CategoryDao.kt** in `data/src/main/java/com/wenubey/data/local/dao/`.
    - `@Dao` interface:
      - `@Query("SELECT * FROM categories WHERE isActive = 1") fun observeActiveCategories(): Flow<List<CategoryEntity>>`
      - `@Query("SELECT * FROM categories") fun observeAllCategories(): Flow<List<CategoryEntity>>`
      - `@Upsert suspend fun upsertAll(categories: List<CategoryEntity>)`
      - `@Upsert suspend fun upsert(category: CategoryEntity)`
      - `@Query("DELETE FROM categories WHERE id = :id") suspend fun deleteById(id: String)`
      - `@Query("DELETE FROM categories") suspend fun clearAll()`

    **Step 9: Create UserDao.kt** in `data/src/main/java/com/wenubey/data/local/dao/`.
    - `@Dao` interface:
      - `@Query("SELECT * FROM users LIMIT 1") fun observeCurrentUser(): Flow<UserEntity?>`
      - `@Query("SELECT * FROM users LIMIT 1") suspend fun getCurrentUser(): UserEntity?`
      - `@Upsert suspend fun upsert(user: UserEntity)`
      - `@Query("DELETE FROM users") suspend fun clearAll()`

    **Step 10: Create WenuCommerceDatabase.kt** in `data/src/main/java/com/wenubey/data/local/`.
    - Package: `com.wenubey.data.local`
    - `@Database(entities = [ProductEntity::class, CategoryEntity::class, UserEntity::class], version = 1, exportSchema = true)`
    - `@TypeConverters(RoomTypeConverters::class)`
    - `abstract class WenuCommerceDatabase : RoomDatabase()`
    - Abstract DAO accessors: `abstract fun productDao(): ProductDao`, `abstract fun categoryDao(): CategoryDao`, `abstract fun userDao(): UserDao`
  </action>
  <verify>
    Run `./gradlew :data:kspDebugKotlin` from project root. It must succeed without errors, confirming Room annotation processing generates implementations for all three DAOs and the database.
    Verify no Room-related KSP tasks run on the `:app` module: `./gradlew :app:compileDebugKotlin 2>&1 | grep -i room` should return no annotation-processing output.
    Verify schema JSON is generated: `ls data/schemas/com.wenubey.data.local.WenuCommerceDatabase/1.json` must exist.
  </verify>
  <done>
    WenuCommerceDatabase compiles with schema version 1. Three entities, three DAOs, and TypeConverters compile without errors. Room KSP runs only in `data` module. Schema JSON file exists at `data/schemas/`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create domain mappers and wire Koin databaseModule</name>
  <files>
    data/src/main/java/com/wenubey/data/local/mapper/ProductMapper.kt
    data/src/main/java/com/wenubey/data/local/mapper/CategoryMapper.kt
    data/src/main/java/com/wenubey/data/local/mapper/UserMapper.kt
    app/src/main/java/com/wenubey/wenucommerce/di/DataModule.kt
    app/src/main/java/com/wenubey/wenucommerce/di/AppModules.kt
  </files>
  <action>
    **Step 1: Create mapper directory** `data/src/main/java/com/wenubey/data/local/mapper/`.

    **Step 2: Create ProductMapper.kt.**
    - Package: `com.wenubey.data.local.mapper`
    - Extension function `fun ProductEntity.toDomain(): Product` — maps all simple columns directly, deserializes JSON columns using the same `Json` instance pattern (or inline `kotlinx.serialization.json.Json.decodeFromString`). Map `status` string to `ProductStatus.valueOf(status)` with a `runCatching` fallback to `ProductStatus.DRAFT`. Map `condition` string to `ProductCondition.valueOf(condition)` with fallback to `ProductCondition.NEW`.
    - Extension function `fun Product.toEntity(): ProductEntity` — maps all fields, serializes nested types to JSON strings using `Json.encodeToString`. Map `status.name` and `condition.name` to strings. Map `id` to `id` (Product.id -> ProductEntity.id).
    - Use a file-level `private val json = Json { ignoreUnknownKeys = true; coerceInputValues = true }` for shared serialization.

    **Step 3: Create CategoryMapper.kt.**
    - `fun CategoryEntity.toDomain(): Category` — maps all columns, deserializes `subcategoriesJson` to `List<Subcategory>`.
    - `fun Category.toEntity(): CategoryEntity` — maps all fields, serializes `subcategories` to JSON.

    **Step 4: Create UserMapper.kt.**
    - `fun UserEntity.toDomain(): User` — maps all columns, deserializes JSON columns (`purchaseHistoryJson`, `signedDevicesJson`, `businessInfoJson`, `productsJson`). Map `role` to `UserRole.valueOf(role)` with fallback. Map `gender` to `Gender.valueOf(gender)` with fallback. Map `id` to `uuid`.
    - `fun User.toEntity(): UserEntity` — maps all fields, serializes nested types. Map `uuid ?: ""` to `id` (UserEntity.id cannot be null).

    **Step 5: Add databaseModule to DataModule.kt.**
    Add a new `val databaseModule = module { ... }` block in DataModule.kt containing:
    - `single { Room.databaseBuilder(get(), WenuCommerceDatabase::class.java, "wenu_commerce_database").apply { if (com.wenubey.data.BuildConfig.DEBUG) fallbackToDestructiveMigration() }.build() }` — Uses `BuildConfig.DEBUG` guard so destructive migration is ONLY in debug builds.
    - `single { get<WenuCommerceDatabase>().productDao() }`
    - `single { get<WenuCommerceDatabase>().categoryDao() }`
    - `single { get<WenuCommerceDatabase>().userDao() }`
    Import: `androidx.room.Room`, `com.wenubey.data.local.WenuCommerceDatabase`.

    **Step 6: Register databaseModule in AppModules.kt.**
    Add `databaseModule` to the `appModules` list. Place it before `repositoryModule` since repositories will later depend on DAOs.

    **Note on fallbackToDestructiveMigration:** The `if (BuildConfig.DEBUG)` guard ensures the success criterion "no fallbackToDestructiveMigration() in release build config" is met. In release builds, Room will throw an `IllegalStateException` if a migration is missing, which is correct — it forces explicit migration objects for schema changes.
  </action>
  <verify>
    Run `./gradlew :app:compileDebugKotlin` — must succeed, confirming Koin module compiles and all imports resolve.
    Grep for `fallbackToDestructiveMigration` — verify it only appears inside a `BuildConfig.DEBUG` conditional.
    Verify mapper files compile: `./gradlew :data:compileDebugKotlin` must succeed.
  </verify>
  <done>
    Three mapper files provide bidirectional Product/Category/User <-> Entity conversion. `databaseModule` provides WenuCommerceDatabase singleton and all three DAOs via Koin. `appModules` list includes `databaseModule`. Full project compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew assembleDebug` completes without errors — full project builds with the new Room infrastructure.
2. Schema JSON file exists at `data/schemas/com.wenubey.data.local.WenuCommerceDatabase/1.json` and contains entity definitions for `products`, `categories`, and `users` tables.
3. `grep -r "room" app/build.gradle.kts` returns zero matches (Room removed from app module).
4. `grep -r "fallbackToDestructiveMigration" data/ app/` shows the call only inside a `BuildConfig.DEBUG` guard.
5. No existing functionality is broken — the app still launches and works as before since no repository has been modified yet.
</verification>

<success_criteria>
- Room schema v1 compiles and generates schema JSON
- Three entities, three DAOs, TypeConverters, and three mappers exist and compile
- Koin databaseModule provides WenuCommerceDatabase + all DAOs
- Room declarations removed from app/build.gradle.kts
- fallbackToDestructiveMigration only in debug build config
- Existing app behavior unchanged (no repository modifications in this plan)
</success_criteria>

<output>
After completion, create `.planning/phases/01-room-foundation/01-01-SUMMARY.md`
</output>
