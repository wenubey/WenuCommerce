---
phase: 01-room-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - data/src/main/java/com/wenubey/data/repository/ProductRepositoryImpl.kt
  - data/src/main/java/com/wenubey/data/repository/CategoryRepositoryImpl.kt
  - app/src/main/java/com/wenubey/wenucommerce/di/DataModule.kt
  - app/src/main/java/com/wenubey/wenucommerce/WenuCommerce.kt
  - data/src/main/java/com/wenubey/data/local/SyncManager.kt
autonomous: true
requirements:
  - SYNC-01
  - SYNC-02
  - SYNC-06

must_haves:
  truths:
    - "Customer opens app with no network and sees previously-synced products and categories from Room cache"
    - "Product detail screen loads from Room — no Firestore callbackFlow is observed by any ViewModel"
    - "Firestore snapshot listeners write data through to Room in the background"
    - "All existing product and category observe/query methods return data from Room DAOs"
    - "Search works against cached Room data — results may be incomplete but functional"
    - "Seller product list, admin product moderation, and customer browse all read from Room"
  artifacts:
    - path: "data/src/main/java/com/wenubey/data/repository/ProductRepositoryImpl.kt"
      provides: "Room-first product repository — read from DAO, sync from Firestore"
      contains: "productDao"
    - path: "data/src/main/java/com/wenubey/data/repository/CategoryRepositoryImpl.kt"
      provides: "Room-first category repository — read from DAO, sync from Firestore"
      contains: "categoryDao"
    - path: "data/src/main/java/com/wenubey/data/local/SyncManager.kt"
      provides: "Application-scoped sync coordinator that starts Firestore listeners"
      contains: "startSync"
  key_links:
    - from: "data/src/main/java/com/wenubey/data/repository/ProductRepositoryImpl.kt"
      to: "data/src/main/java/com/wenubey/data/local/dao/ProductDao.kt"
      via: "Constructor injection — all observe/get methods delegate to productDao"
      pattern: "productDao\\.observe"
    - from: "data/src/main/java/com/wenubey/data/repository/CategoryRepositoryImpl.kt"
      to: "data/src/main/java/com/wenubey/data/local/dao/CategoryDao.kt"
      via: "Constructor injection — observeCategories delegates to categoryDao"
      pattern: "categoryDao\\.observeActiveCategories"
    - from: "data/src/main/java/com/wenubey/data/local/SyncManager.kt"
      to: "Firestore snapshot listeners"
      via: "callbackFlow collecting into DAO upsert"
      pattern: "addSnapshotListener"
    - from: "app/src/main/java/com/wenubey/wenucommerce/WenuCommerce.kt"
      to: "data/src/main/java/com/wenubey/data/local/SyncManager.kt"
      via: "Koin get() in Application.onCreate — starts sync on app launch"
      pattern: "SyncManager"
---

<objective>
Migrate ProductRepositoryImpl and CategoryRepositoryImpl to the Room-first write-through pattern. All read operations (observe, get, search) now query Room DAOs. Firestore snapshot listeners become the write path — they push data into Room in the background via an application-scoped SyncManager.

Purpose: After this plan, the customer browsing experience works entirely from Room cache. Offline users see cached products and categories. Firestore listeners keep Room updated when the network is available.

Output: Modified ProductRepositoryImpl and CategoryRepositoryImpl reading from Room, a SyncManager class managing Firestore listener lifecycle at application scope, and Koin + Application class wiring.
</objective>

<execution_context>
@/Users/wenubey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wenubey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-room-foundation/01-RESEARCH.md
@.planning/phases/01-room-foundation/01-01-SUMMARY.md

@data/src/main/java/com/wenubey/data/repository/ProductRepositoryImpl.kt
@data/src/main/java/com/wenubey/data/repository/CategoryRepositoryImpl.kt
@domain/src/main/java/com/wenubey/domain/repository/ProductRepository.kt
@domain/src/main/java/com/wenubey/domain/repository/CategoryRepository.kt
@data/src/main/java/com/wenubey/data/local/dao/ProductDao.kt
@data/src/main/java/com/wenubey/data/local/dao/CategoryDao.kt
@data/src/main/java/com/wenubey/data/local/mapper/ProductMapper.kt
@data/src/main/java/com/wenubey/data/local/mapper/CategoryMapper.kt
@data/src/main/java/com/wenubey/data/local/entity/ProductEntity.kt
@data/src/main/java/com/wenubey/data/local/entity/CategoryEntity.kt
@app/src/main/java/com/wenubey/wenucommerce/di/DataModule.kt
@app/src/main/java/com/wenubey/wenucommerce/di/AppModules.kt
@app/src/main/java/com/wenubey/wenucommerce/WenuCommerce.kt
@data/src/main/java/com/wenubey/data/util/Constants.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncManager and migrate ProductRepositoryImpl to Room-first</name>
  <files>
    data/src/main/java/com/wenubey/data/local/SyncManager.kt
    data/src/main/java/com/wenubey/data/repository/ProductRepositoryImpl.kt
    app/src/main/java/com/wenubey/wenucommerce/di/DataModule.kt
  </files>
  <action>
    **Step 1: Create SyncManager.kt** in `data/src/main/java/com/wenubey/data/local/`.
    - Package: `com.wenubey.data.local`
    - Class `SyncManager(private val firestore: FirebaseFirestore, private val productDao: ProductDao, private val categoryDao: CategoryDao, private val dispatcherProvider: DispatcherProvider)`
    - Contains a `private val syncScope = CoroutineScope(SupervisorJob() + dispatcherProvider.io())` for application-lifetime coroutines.
    - Method `fun startSync()` launches Firestore snapshot listeners in `syncScope`:

      **Product sync listener:**
      ```
      syncScope.launch {
          callbackFlow {
              val listener = firestore.collection(PRODUCTS_COLLECTION)
                  .addSnapshotListener { snapshot, error ->
                      if (error != null) { Timber.e(error, "Product sync error"); return@addSnapshotListener }
                      val products = snapshot?.documents?.mapNotNull { doc ->
                          try { doc.toObject(Product::class.java)?.toEntity() } catch (e: Exception) { Timber.e(e, "Product sync deserialize failed: ${doc.id}"); null }
                      } ?: emptyList()
                      trySend(products)
                  }
              awaitClose { listener.remove() }
          }.catch { e -> Timber.e(e, "Product sync flow failed") }
           .collect { entities -> productDao.upsertAll(entities) }
      }
      ```

      **Category sync listener** (same pattern):
      ```
      syncScope.launch {
          callbackFlow {
              val listener = firestore.collection(CATEGORIES_COLLECTION)
                  .addSnapshotListener { snapshot, error ->
                      if (error != null) { Timber.e(error, "Category sync error"); return@addSnapshotListener }
                      val categories = snapshot?.documents?.mapNotNull { doc ->
                          try { doc.toObject(Category::class.java)?.toEntity() } catch (e: Exception) { Timber.e(e, "Category sync deserialize failed: ${doc.id}"); null }
                      } ?: emptyList()
                      trySend(categories)
                  }
              awaitClose { listener.remove() }
          }.catch { e -> Timber.e(e, "Category sync flow failed") }
           .collect { entities -> categoryDao.upsertAll(entities) }
      }
      ```

    - Import `toEntity()` from mapper files.
    - Import PRODUCTS_COLLECTION and CATEGORIES_COLLECTION from Constants.

    **Step 2: Migrate ProductRepositoryImpl to Room-first.**
    Add `private val productDao: ProductDao` to the constructor parameters (Koin will inject it).

    Modify read-path methods to use Room DAO:

    - `observeSellerProducts(sellerId)`: Return `productDao.observeSellerProducts(sellerId).map { entities -> entities.map { it.toDomain() } }` instead of `callbackFlow`. Remove the Firestore snapshot listener code.
    - `observeActiveProductsByCategory(categoryId)`: Return `productDao.observeActiveProductsByCategory(categoryId).map { entities -> entities.map { it.toDomain() } }`. Remove Firestore listener.
    - `observeActiveProductsByCategoryAndSubcategory(categoryId, subcategoryId)`: If `subcategoryId` is null or blank, delegate to `productDao.observeActiveProductsByCategory(categoryId)`. Otherwise delegate to `productDao.observeActiveProductsByCategoryAndSubcategory(categoryId, subcategoryId)`. Map entities to domain. Remove Firestore listener.
    - `observeProductsByStatus(status)`: Return `productDao.observeProductsByStatus(status.name).map { entities -> entities.map { it.toDomain() } }`. Remove Firestore listener.
    - `getProductById(productId)`: First try Room (`productDao.getProductById(productId)?.toDomain()`). If found, return it. If null, fall back to Firestore (existing code), and on success also `productDao.upsert(product.toEntity())` to cache it.
    - `getSellerProducts(sellerId)`: Keep existing Firestore implementation BUT also cache results: after fetching from Firestore, `productDao.upsertAll(products.map { it.toEntity() })`. Return the fetched list.
    - `getStorefrontProducts(sellerId)`: Same pattern as getSellerProducts — fetch from Firestore, cache in Room, return.
    - `searchActiveProducts(query, categoryId, subcategoryId)`: Replace Firestore search with Room search. Normalize query, tokenize. Use `productDao.searchActiveProducts(tokens.first())` (first token for the LIKE query), then filter client-side for all tokens. Apply categoryId/subcategoryId post-filter. Return as `Result<List<Product>>`. Wrap in `safeApiCall`. This means search works offline against cached data.
    - `searchAllProducts(query, categoryId, subcategoryId)`: Same approach using `productDao.searchAllProducts(tokens.first())`, then client-side multi-token + category filter.

    Write-path methods (createProduct, updateProduct, submitForReview, approveProduct, suspendProduct, archiveProduct, unarchiveProduct, adminUpdateProduct, incrementViewCount, decrementStock, addProductToSellerDocument) KEEP their existing Firestore write logic unchanged. After a successful Firestore write, also update Room cache where applicable:
    - `createProduct`: After successful Firestore set, `productDao.upsert(newProduct.toEntity())`.
    - `updateProduct`: After successful Firestore update, `productDao.upsert(updatedProduct.toEntity())`.
    - Other write methods: The SyncManager's snapshot listener will pick up the changes and upsert them into Room automatically, so explicit Room writes are optional but recommended for immediate UI feedback. Add `productDao.upsert(...)` after `approveProduct` and `suspendProduct` for immediate status reflection.

    Import `toDomain()` and `toEntity()` from `com.wenubey.data.local.mapper.*`.

    **Step 3: Register SyncManager in Koin (DataModule.kt).**
    Add to `repositoryModule` or create a new `val syncModule = module { single { SyncManager(get(), get(), get(), get()) } }`.
    If creating syncModule, also register it in AppModules.kt.
    The constructor parameters (firestore, productDao, categoryDao, dispatcherProvider) are all already provided by other Koin modules.
  </action>
  <verify>
    `./gradlew :data:compileDebugKotlin` succeeds — ProductRepositoryImpl compiles with new DAO dependency.
    `./gradlew :app:compileDebugKotlin` succeeds — Koin module resolves SyncManager.
    Grep for `callbackFlow` in `ProductRepositoryImpl.kt` — should return zero matches (all observe methods now delegate to DAO).
  </verify>
  <done>
    ProductRepositoryImpl reads all observe/query data from Room DAO. Firestore snapshot listener runs in SyncManager at application scope. Write operations still go to Firestore and optionally cache in Room. Search queries Room instead of Firestore. SyncManager is registered in Koin.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate CategoryRepositoryImpl to Room-first and wire SyncManager startup</name>
  <files>
    data/src/main/java/com/wenubey/data/repository/CategoryRepositoryImpl.kt
    app/src/main/java/com/wenubey/wenucommerce/WenuCommerce.kt
    app/src/main/java/com/wenubey/wenucommerce/di/AppModules.kt
  </files>
  <action>
    **Step 1: Migrate CategoryRepositoryImpl to Room-first.**
    Add `private val categoryDao: CategoryDao` to the constructor parameters.

    Modify read-path methods:
    - `observeCategories()`: Return `categoryDao.observeActiveCategories().map { entities -> entities.map { it.toDomain() } }`. Remove the entire Firestore `callbackFlow` block. The sync is handled by SyncManager.
    - `getCategories()`: Keep existing Firestore fetch BUT also cache results: after fetching, `categoryDao.upsertAll(categories.map { it.toEntity() })`. Return the fetched list. This method is used for one-shot fetches and should try Firestore first for fresh data, falling back to Room if Firestore fails (offline).

    Actually, refine `getCategories()` to be offline-aware:
    ```kotlin
    override suspend fun getCategories(): Result<List<Category>> = safeApiCall(ioDispatcher) {
        try {
            // Try Firestore first for fresh data
            val snapshot = categoriesCollection.whereEqualTo("isActive", true).get().await()
            val categories = snapshot.documents.mapNotNull { doc ->
                try { doc.toObject(Category::class.java) } catch (e: Exception) {
                    Timber.e(e, "Failed to deserialize category: ${doc.id}"); null
                }
            }
            // Cache in Room
            categoryDao.upsertAll(categories.map { it.toEntity() })
            categories
        } catch (e: Exception) {
            Timber.w(e, "Firestore getCategories failed, falling back to Room cache")
            // Fallback to Room cache
            categoryDao.observeActiveCategories().first().map { it.toDomain() }
        }
    }
    ```

    Write-path methods (createCategory, addSubcategory, updateCategory, deleteCategory, uploadCategoryImage) KEEP their existing Firestore logic. After successful Firestore writes, also update Room:
    - `createCategory`: After Firestore set, `categoryDao.upsert(newCategory.toEntity())`.
    - `updateCategory`: After Firestore update, `categoryDao.upsert(updatedCategory.toEntity())`.
    - `deleteCategory`: After Firestore soft-delete, update Room: `categoryDao.deleteById(categoryId)` (or upsert with isActive=false — deleteById is simpler since the observe query filters by isActive=1).
    - `addSubcategory`: The SyncManager listener will pick up the change automatically. No explicit Room write needed.

    Import `toDomain()` and `toEntity()` from `com.wenubey.data.local.mapper.CategoryMapper`.
    Import `kotlinx.coroutines.flow.first` for the getCategories fallback.

    **Step 2: Wire SyncManager startup in WenuCommerce Application class.**
    In `WenuCommerce.onCreate()`, after `startKoin { ... }`, add:
    ```kotlin
    // Start Firestore-to-Room sync listeners
    val syncManager: SyncManager = org.koin.java.KoinJavaComponent.get(SyncManager::class.java)
    syncManager.startSync()
    ```
    Alternatively, use `getKoin().get<SyncManager>()` if available after startKoin completes. The cleanest approach: call it immediately after the `startKoin` block since Koin is initialized by that point.

    Import `com.wenubey.data.local.SyncManager`.

    **Step 3: Ensure AppModules.kt includes syncModule** (if created as a separate module in Task 1, verify it is in appModules list).
  </action>
  <verify>
    `./gradlew assembleDebug` succeeds — full project builds.
    Grep for `callbackFlow` in `CategoryRepositoryImpl.kt` — should only appear in zero places (the observe method no longer uses it; the sync is in SyncManager).
    Grep for `SyncManager` in `WenuCommerce.kt` — must appear, confirming sync starts on app launch.
    Verify the app can be installed on a device/emulator: `./gradlew installDebug` or manual verification.
  </verify>
  <done>
    CategoryRepositoryImpl reads from Room DAO. SyncManager starts on app launch in Application.onCreate(). Both Product and Category sync listeners are active at application scope. The app builds and all existing functionality works — browsing, search, product management — now backed by Room cache. Offline browsing works for previously-synced data.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew assembleDebug` completes without errors.
2. `grep -rn "callbackFlow" data/src/main/java/com/wenubey/data/repository/ProductRepositoryImpl.kt` returns zero matches.
3. `grep -rn "callbackFlow" data/src/main/java/com/wenubey/data/repository/CategoryRepositoryImpl.kt` returns zero matches (only in SyncManager now).
4. `grep -rn "productDao" data/src/main/java/com/wenubey/data/repository/ProductRepositoryImpl.kt` shows DAO usage in observe/get/search methods.
5. `grep -rn "categoryDao" data/src/main/java/com/wenubey/data/repository/CategoryRepositoryImpl.kt` shows DAO usage in observe/get methods.
6. `grep -rn "SyncManager" app/src/main/java/com/wenubey/wenucommerce/WenuCommerce.kt` confirms startup wiring.
7. `grep -rn "callbackFlow" data/src/main/java/com/wenubey/data/local/SyncManager.kt` confirms Firestore listeners live here.
</verification>

<success_criteria>
- ProductRepositoryImpl: all observe methods return DAO Flows, no direct Firestore observation by ViewModels
- CategoryRepositoryImpl: observeCategories returns DAO Flow, no direct Firestore observation
- SyncManager: Firestore snapshot listeners for products and categories run at application scope
- Search: queries Room instead of Firestore (works offline with cached data)
- Write operations: still go to Firestore, with Room cache updates for immediate UI feedback
- App compiles, builds, and existing functionality works
</success_criteria>

<output>
After completion, create `.planning/phases/01-room-foundation/01-02-SUMMARY.md`
</output>
